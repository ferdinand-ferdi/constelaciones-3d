<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Constructor de Mu√±ecos V2 ¬∑ Cartoon Humanos</title>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #e5f0ff;
      color: #111827;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }

    h1 {
      text-align: center;
      margin: 12px 0;
      color: #1d4ed8;
      text-shadow: 0 0 10px rgba(37, 99, 235, 0.35);
      font-size: 1.5rem;
    }

    #app {
      position: relative;
      width: 100vw;
      height: calc(100vh - 54px);
      display: flex;
    }

    #sidebar {
      width: 290px;
      max-width: 320px;
      min-width: 260px;
      height: 100%;
      background: rgba(255, 255, 255, 0.96);
      border-right: 1px solid #d4d4d8;
      box-shadow: 4px 0 18px rgba(15, 23, 42, 0.12);
      padding: 12px;
      overflow-y: auto;
    }

    #canvas-container {
      flex: 1;
      height: 100%;
      position: relative;
      background: #c7d2fe;
      cursor: grab;
    }

    #canvas-container:active {
      cursor: grabbing;
    }

    .section-title {
      font-size: 0.85rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: #6b7280;
      margin: 10px 0 6px;
    }

    .field-group {
      margin-bottom: 8px;
    }

    label {
      display: block;
      font-size: 0.78rem;
      font-weight: 600;
      margin-bottom: 3px;
      color: #374151;
    }

    select {
      width: 100%;
      padding: 4px 6px;
      font-size: 0.8rem;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      outline: none;
    }

    select:focus {
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.4);
      background: #ffffff;
    }

    .row-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }

    .btn {
      width: 100%;
      border: none;
      border-radius: 6px;
      padding: 8px 10px;
      font-size: 0.82rem;
      font-weight: 700;
      cursor: pointer;
      margin-top: 6px;
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
    }

    .btn-main {
      background: linear-gradient(to right, #2563eb, #38bdf8);
      color: #f9fafb;
      box-shadow: 0 2px 8px rgba(37, 99, 235, 0.5);
    }

    .btn-main:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.6);
    }

    .btn-secondary {
      background: linear-gradient(to right, #6b7280, #9ca3af);
      color: #f9fafb;
    }

    .btn-secondary:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(55, 65, 81, 0.5);
    }

    .btn-danger {
      background: linear-gradient(to right, #dc2626, #f97373);
      color: #fef2f2;
    }

    .btn-danger:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(220, 38, 38, 0.6);
    }

    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      line-height: 1.3;
      margin-top: 4px;
    }

    .pill {
      display: inline-block;
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: #eff6ff;
      color: #1d4ed8;
      margin-right: 4px;
      margin-bottom: 4px;
    }

    #configSummary {
      font-size: 0.75rem;
      color: #4b5563;
      margin-top: 6px;
      line-height: 1.3;
      border-radius: 4px;
      padding: 4px 6px;
      background: #f3f4ff;
    }

    #instructions {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.92);
      border-radius: 999px;
      padding: 6px 16px;
      font-size: 0.8rem;
      color: #0f172a;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.35);
      pointer-events: none;
      white-space: nowrap;
      border: 1px solid #e5e7eb;
    }

    #btnDeleteFloating {
      position: absolute;
      top: 12px;
      right: 12px;
      border: 1px solid #e5e7eb;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 999px;
      padding: 8px 10px;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    #btnDeleteFloating:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.25);
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <h1>Constructor de Mu√±ecos V2 ¬∑ Humanos Cartoon 3D</h1>

  <div id="app">
    <aside id="sidebar">
      <div class="section-title">1. Tipo base</div>
      <div class="field-group row-2">
        <div>
          <label for="tipoPersona">Persona</label>
          <select id="tipoPersona">
            <option value="adulto_hombre">Adulto ¬∑ Hombre</option>
            <option value="adulto_mujer">Adulto ¬∑ Mujer</option>
            <option value="anciano_hombre">Anciano</option>
            <option value="anciano_mujer">Anciana</option>
            <option value="nino">Ni√±o</option>
            <option value="nina">Ni√±a</option>
          </select>
        </div>
        <div>
          <label for="colorRopa">Color de ropa</label>
          <select id="colorRopa">
            <option value="#2563eb">Azul</option>
            <option value="#16a34a">Verde</option>
            <option value="#f97316">Naranja</option>
            <option value="#db2777">Rosa</option>
            <option value="#0f172a">Negro</option>
            <option value="#6b21a8">Morado</option>
          </select>
        </div>
      </div>

      <div class="section-title">2. Ojos</div>
      <div class="field-group row-2">
        <div>
          <label for="tamOjos">Tama√±o</label>
          <select id="tamOjos">
            <option value="pequenos">Peque√±os</option>
            <option value="medianos" selected>Medianos</option>
            <option value="grandes">Grandes</option>
          </select>
        </div>
        <div>
          <label for="colorOjos">Color</label>
          <select id="colorOjos">
            <option value="marron" selected>Marr√≥n</option>
            <option value="verdes">Verdes</option>
            <option value="azules">Azules</option>
            <option value="negros">Negros</option>
          </select>
        </div>
      </div>

      <div class="section-title">3. Cabello</div>
      <div class="field-group row-2">
        <div>
          <label for="largoCabello">Largo</label>
          <select id="largoCabello">
            <option value="corto">Corto</option>
            <option value="medio">Medio</option>
            <option value="largo">Largo</option>
          </select>
        </div>
        <div>
          <label for="colorCabello">Color</label>
          <select id="colorCabello">
            <option value="castano" selected>Casta√±o</option>
            <option value="negro">Negro</option>
            <option value="rubio">Rubio</option>
            <option value="rojo">Rojo</option>
            <option value="cano">Canoso</option>
          </select>
        </div>
      </div>

      <div class="section-title">4. Cuerpo</div>
      <div class="field-group row-2">
        <div>
          <label for="estatura">Estatura</label>
          <select id="estatura">
            <option value="baja">Baja</option>
            <option value="media" selected>Media</option>
            <option value="alta">Alta</option>
          </select>
        </div>
        <div>
          <label for="contextura">Contextura</label>
          <select id="contextura">
            <option value="delgada">Delgada</option>
            <option value="gruesa">Gruesa</option>
            <option value="obesa">Obesa</option>
          </select>
        </div>
      </div>

      <div class="section-title">5. Expresi√≥n</div>
      <div class="field-group">
        <label for="expresion">Cara</label>
        <select id="expresion">
          <option value="neutra">Neutra</option>
          <option value="alegre" selected>Alegre</option>
          <option value="triste">Triste</option>
          <option value="enojada">Enojada</option>
          <option value="picara">P√≠cara</option>
          <option value="malvada">Malvada</option>
        </select>
        <p class="hint">
          <span class="pill">üëÅ ojos cartoon</span>
          <span class="pill">üëÑ boca curva</span>
          <span class="pill">üë§ cuerpo segmentado</span>
        </p>
      </div>

      <button class="btn btn-main" id="btnCrear">‚ûï Crear mu√±eco humano V2</button>

      <div id="configSummary"></div>

      <div class="section-title" style="margin-top: 14px;">Acciones</div>
      <button class="btn btn-secondary" id="btnFoto">üì∑ Guardar imagen</button>
      <button class="btn btn-danger" id="btnBorrar">üóëÔ∏è Borrar mu√±eco seleccionado</button>
      <button class="btn btn-secondary" id="btnReset">üîÑ Limpiar escena</button>

      <p class="hint">
        Interacci√≥n:
        <br>‚Ä¢ Click para seleccionar
        <br>‚Ä¢ Arrastra para mover (plano X/Z)
        <br>‚Ä¢ Shift + arrastre: rotar sobre Y
        <br>‚Ä¢ Tecla R: giro incremental
        <br>‚Ä¢ Supr/Backspace o üóëÔ∏è: borrar selecci√≥n
      </p>
    </aside>

    <main id="canvas-container">
      <div id="instructions">
        Click para seleccionar ¬∑ Arrastra para mover ¬∑ Shift + arrastre rota ¬∑ R rota 22.5¬∞ ¬∑ Supr borra
      </div>
      <button id="btnDeleteFloating" title="Eliminar selecci√≥n">üóëÔ∏è</button>
    </main>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // === DOM ===
    const container = document.getElementById('canvas-container');
    const btnCrear = document.getElementById('btnCrear');
    const btnFoto = document.getElementById('btnFoto');
    const btnBorrar = document.getElementById('btnBorrar');
    const btnReset = document.getElementById('btnReset');
    const configSummary = document.getElementById('configSummary');

    const tipoPersonaEl = document.getElementById('tipoPersona');
    const colorRopaEl = document.getElementById('colorRopa');
    const tamOjosEl = document.getElementById('tamOjos');
    const colorOjosEl = document.getElementById('colorOjos');
    const largoCabelloEl = document.getElementById('largoCabello');
    const colorCabelloEl = document.getElementById('colorCabello');
    const estaturaEl = document.getElementById('estatura');
    const contexturaEl = document.getElementById('contextura');
    const expresionEl = document.getElementById('expresion');

    // === THREE BASICS ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let objects = [];
    let selectedObject = null;
    let isDragging = false;
    let draggedObject = null;
    let isRotating = false;
    let rotateStartX = 0;
    let rotateStartY = 0;
    let selectionHelper = null;

    // === GEOMETR√çAS COMPARTIDAS ===
    const geoHead = new THREE.SphereGeometry(0.55, 32, 32);

    const geoPelvis = new THREE.BoxGeometry(0.6, 0.25, 0.35);
    const geoTorso = new THREE.BoxGeometry(0.7, 0.9, 0.4);
    const geoNeck = new THREE.CylinderGeometry(0.12, 0.12, 0.2, 18);

    const geoUpperArm = new THREE.BoxGeometry(0.18, 0.45, 0.18);
    const geoLowerArm = new THREE.BoxGeometry(0.16, 0.42, 0.16);
    const geoHand = new THREE.BoxGeometry(0.18, 0.16, 0.18);

    const geoThigh = new THREE.BoxGeometry(0.25, 0.55, 0.25);
    const geoCalf = new THREE.BoxGeometry(0.23, 0.52, 0.23);
    const geoFoot = new THREE.BoxGeometry(0.3, 0.12, 0.45);

    const geoBaseDisc = new THREE.CylinderGeometry(0.5, 0.5, 0.08, 28);

    const geoEye = new THREE.SphereGeometry(0.09, 20, 20);
    const geoPupil = new THREE.SphereGeometry(0.035, 18, 18);
    const geoHighlight = new THREE.SphereGeometry(0.015, 10, 10);
    const geoNose = new THREE.BoxGeometry(0.08, 0.08, 0.18);
    const geoHairCap = new THREE.SphereGeometry(0.6, 24, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const geoHairBack = new THREE.BoxGeometry(0.8, 1.0, 0.5);
    const geoLid = new THREE.BoxGeometry(0.32, 0.12, 0.06);
    const geoBrow = new THREE.BoxGeometry(0.32, 0.045, 0.04);

    // === MATERIALES COMPARTIDOS ===
    const matSkin = new THREE.MeshStandardMaterial({ color: 0xf5c49b, roughness: 0.55, metalness: 0.15 });
    const matSkinDark = new THREE.MeshStandardMaterial({ color: 0xd29b6c, roughness: 0.55, metalness: 0.15 });

    const matEyeWhite = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.2,
      metalness: 0.1
    });

    const matHairBlack = new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 0.45, metalness: 0.15 });
    const matHairBrown = new THREE.MeshStandardMaterial({ color: 0x4b2b16, roughness: 0.45, metalness: 0.15 });
    const matHairRed   = new THREE.MeshStandardMaterial({ color: 0xb91c1c, roughness: 0.55, metalness: 0.15 });
    const matHairBlond = new THREE.MeshStandardMaterial({ color: 0xfacc15, roughness: 0.6,  metalness: 0.15 });
    const matHairGray  = new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness: 0.7,  metalness: 0.15 });

    const matBase = new THREE.MeshStandardMaterial({ color: 0xe5e7eb, roughness: 0.9, metalness: 0.05 });

    // === ENUMS DE OPCIONES ===
    const OJOS_TAM = {
      pequenos: { escala: 0.7, offsetY: 0.04, separacion: 0.13 },
      medianos: { escala: 1.0, offsetY: 0.06, separacion: 0.16 },
      grandes:  { escala: 1.4, offsetY: 0.08, separacion: 0.2 }
    };

    const OJOS_COLOR = {
      verdes:  0x166534,
      marron:  0x4b371c,
      negros:  0x020617,
      azules:  0x1d4ed8
    };

    const CABELLO_COLOR = {
      castano: matHairBrown,
      negro:   matHairBlack,
      rubio:   matHairBlond,
      rojo:    matHairRed,
      cano:    matHairGray
    };

    const ESTATURA = {
      baja:  0.9,
      media: 1.0,
      alta:  1.15
    };

    const CONTEXTURA = {
      delgada: 0.9,
      gruesa:  1.15,
      obesa:   1.3
    };

    function initThree() {
      scene = new THREE.Scene();
      const bg = new THREE.Color(0xe5f0ff);
      scene.background = bg;
      scene.fog = new THREE.Fog(bg, 30, 120);

      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(18, 16, 32);
      camera.lookAt(0, 3, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      if ('outputColorSpace' in renderer) {
        renderer.outputColorSpace = THREE.SRGBColorSpace;
      }

      container.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI / 2 - 0.1;
      controls.minDistance = 12;
      controls.maxDistance = 60;

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
    }

    function setupLights() {
      const hemi = new THREE.HemisphereLight(0xffffff, 0xf3f4f6, 1.15);
      scene.add(hemi);

      const amb = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(amb);

      const dir = new THREE.DirectionalLight(0xffffff, 0.55);
      dir.position.set(20, 25, 12);
      dir.castShadow = true;
      dir.shadow.mapSize.set(2048, 2048);
      dir.shadow.camera.left = -40;
      dir.shadow.camera.right = 40;
      dir.shadow.camera.top = 40;
      dir.shadow.camera.bottom = -40;
      scene.add(dir);

      const fillRight = new THREE.DirectionalLight(0xe0f2fe, 0.35);
      fillRight.position.set(-25, 18, -10);
      scene.add(fillRight);

      const faceLight = new THREE.SpotLight(0xffffff, 0.75, 70, Math.PI / 4, 0.4, 1);
      faceLight.position.set(0, 18, 28);
      faceLight.target.position.set(0, 4, 0);
      scene.add(faceLight);
      scene.add(faceLight.target);
    }

    function createRoom() {
      // Suelo
      const floorGeo = new THREE.PlaneGeometry(40, 25);
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0xf9fafb,
        roughness: 0.6,
        metalness: 0.02
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // Zona central azul cielo
      const centerGeo = new THREE.CircleGeometry(6.5, 40);
      const centerMat = new THREE.MeshStandardMaterial({
        color: 0xdbeafe,
        roughness: 0.9,
        metalness: 0
      });
      const center = new THREE.Mesh(centerGeo, centerMat);
      center.rotation.x = -Math.PI / 2;
      center.position.y = 0.01;
      scene.add(center);

      // Pared del fondo
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9,
        metalness: 0.02
      });
      const wallGeo = new THREE.BoxGeometry(40, 10, 0.5);
      const wall = new THREE.Mesh(wallGeo, wallMat);
      wall.position.set(0, 5, -12.5);
      scene.add(wall);

      // Laterales suaves
      const sideGeo = new THREE.BoxGeometry(0.5, 10, 25);
      const sideLeft = new THREE.Mesh(sideGeo, wallMat);
      sideLeft.position.set(-20, 5, 0);
      const sideRight = sideLeft.clone();
      sideRight.position.x = 20;
      scene.add(sideLeft, sideRight);
    }

    // === INTERACCI√ìN ===
    function setupInteraction() {
      const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

      function getPointer(e) {
        if (e.changedTouches && e.changedTouches.length > 0) return e.changedTouches[0];
        return e;
      }

      function onDown(e) {
        e.preventDefault();

        const pointer = getPointer(e);
        const rect = container.getBoundingClientRect();
        mouse.x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((pointer.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(objects, true);

        if (intersects.length > 0) {
          let target = intersects[0].object;
          while (target.parent && target.parent.type !== 'Scene') {
            if (objects.includes(target.parent)) {
              target = target.parent;
              break;
            }
            target = target.parent;
          }

          if (objects.includes(target)) {
            selectObject(target);

            if (e.shiftKey) {
              isRotating = true;
              controls.enabled = false;
              rotateStartX = pointer.clientX;
              rotateStartY = target.rotation.y;
              return;
            }

            isDragging = true;
            draggedObject = target;
            controls.enabled = false;
            target.position.y = (target.userData.baseHeight || 0) + 0.4;
          }
        } else {
          selectObject(null);
        }
      }

      function onMove(e) {
        const pointer = getPointer(e);

        if (isRotating && selectedObject) {
          const deltaX = pointer.clientX - rotateStartX;
          selectedObject.rotation.y = rotateStartY + deltaX * 0.01;
          return;
        }

        if (!isDragging || !draggedObject) return;
        e.preventDefault();

        const rect = container.getBoundingClientRect();
        mouse.x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((pointer.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectPoint);

        if (intersectPoint) {
          const maxX = 18;
          const maxZ = 11;
          draggedObject.position.x = THREE.MathUtils.clamp(intersectPoint.x, -maxX, maxX);
          draggedObject.position.z = THREE.MathUtils.clamp(intersectPoint.z, -maxZ, maxZ);
        }
      }

      function onUp() {
        if (isRotating) {
          controls.enabled = true;
          isRotating = false;
          return;
        }
        if (draggedObject) {
          draggedObject.position.y = draggedObject.userData.baseHeight || 0;
          draggedObject = null;
        }
        isDragging = false;
        controls.enabled = true;
      }

      container.addEventListener('mousedown', onDown);
      container.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);

      container.addEventListener('touchstart', onDown, { passive: false });
      container.addEventListener('touchmove', onMove, { passive: false });
      window.addEventListener('touchend', onUp);
    }

    function selectObject(obj) {
      if (selectedObject && selectedObject !== obj) {
        setEmissive(selectedObject, 0x000000);
        if (selectionHelper) {
          scene.remove(selectionHelper);
          selectionHelper = null;
        }
      }
      selectedObject = obj;
      if (obj) {
        setEmissive(obj, 0x222222);
        selectionHelper = new THREE.BoxHelper(obj, 0x3b82f6);
        selectionHelper.material.transparent = true;
        selectionHelper.material.opacity = 0.6;
        scene.add(selectionHelper);
      }
    }

    function setEmissive(obj, colorHex) {
      obj.traverse(child => {
        if (child.isMesh && child.material && child.material.emissive) {
          child.material.emissive.setHex(colorHex);
        }
      });
    }

    // === RESUMEN DE CONFIGURACI√ìN ===
    function actualizarResumenConfig() {
      const tipoTexto = tipoPersonaEl.options[tipoPersonaEl.selectedIndex].textContent;
      const ojosTam = tamOjosEl.options[tamOjosEl.selectedIndex].textContent;
      const ojosCol = colorOjosEl.options[colorOjosEl.selectedIndex].textContent;
      const pelLargo = largoCabelloEl.options[largoCabelloEl.selectedIndex].textContent;
      const pelColor = colorCabelloEl.options[colorCabelloEl.selectedIndex].textContent;
      const estText = estaturaEl.options[estaturaEl.selectedIndex].textContent;
      const ctxText = contexturaEl.options[contexturaEl.selectedIndex].textContent;
      const expText = expresionEl.options[expresionEl.selectedIndex].textContent;

      configSummary.textContent =
        `Mu√±eco humano: ${tipoTexto} ¬∑ Ojos ${ojosTam.toLowerCase()} ${ojosCol.toLowerCase()} ¬∑ ` +
        `Cabello ${pelLargo.toLowerCase()} ${pelColor.toLowerCase()} ¬∑ ` +
        `Estatura ${estText.toLowerCase()}, contextura ${ctxText.toLowerCase()} ¬∑ ` +
        `Expresi√≥n ${expText.toLowerCase()}.`;
    }

    [
      tipoPersonaEl, colorRopaEl, tamOjosEl, colorOjosEl,
      largoCabelloEl, colorCabelloEl, estaturaEl,
      contexturaEl, expresionEl
    ].forEach(el => {
      el.addEventListener('change', actualizarResumenConfig);
    });

    // === CARA EXPRESIVA ===
    function addFaceDetails(head, options) {
      const { ojosTamKey, ojosColorKey, expresion } = options;
      const ojosInfo = OJOS_TAM[ojosTamKey];
      const irisColor = new THREE.Color(OJOS_COLOR[ojosColorKey] ?? OJOS_COLOR.marron);

      const separation = ojosInfo.separacion;
      const scale = ojosInfo.escala;
      const offsetY = ojosInfo.offsetY;

      const irisMat = new THREE.MeshStandardMaterial({
        color: irisColor,
        roughness: 0.25,
        metalness: 0.3
      });
      const pupilMat = new THREE.MeshStandardMaterial({
        color: 0x020617,
        roughness: 0.2,
        metalness: 0.4
      });

      // Ojo izquierdo
      const eyeL = new THREE.Mesh(geoEye, matEyeWhite);
      eyeL.scale.set(scale, scale, scale);
      eyeL.position.set(-separation, offsetY, 0.43);

      const irisL = new THREE.Mesh(
        new THREE.CylinderGeometry(0.07 * scale, 0.07 * scale, 0.01, 20),
        irisMat
      );
      irisL.rotation.x = Math.PI / 2;
      irisL.position.set(0, 0, 0.09);

      const pupilL = new THREE.Mesh(geoPupil, pupilMat);
      pupilL.scale.set(scale, scale, scale);
      pupilL.position.set(0, 0, 0.1);

      const highlightL = new THREE.Mesh(
        geoHighlight,
        new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0xffffff,
          emissiveIntensity: 0.7
        })
      );
      highlightL.position.set(-0.02, 0.02, 0.12);

      eyeL.add(irisL, pupilL, highlightL);

      // Ojo derecho
      const eyeR = eyeL.clone(true);
      eyeR.position.x = separation;

      head.add(eyeL, eyeR);

      // P√ÅRPADOS
      const lidMat = new THREE.MeshStandardMaterial({
        color: 0xfaccbc,
        roughness: 0.6,
        metalness: 0.05
      });

      const topLidL = new THREE.Mesh(geoLid, lidMat);
      const topLidR = new THREE.Mesh(geoLid, lidMat);
      const bottomLidL = new THREE.Mesh(geoLid, lidMat);
      const bottomLidR = new THREE.Mesh(geoLid, lidMat);

      const lidOffsetZ = 0.43;
      topLidL.position.set(-separation, offsetY + 0.05, lidOffsetZ);
      topLidR.position.set(separation, offsetY + 0.05, lidOffsetZ);
      bottomLidL.position.set(-separation, offsetY - 0.05, lidOffsetZ);
      bottomLidR.position.set(separation, offsetY - 0.05, lidOffsetZ);

      // CEJAS
      const browMat = new THREE.MeshStandardMaterial({
        color: 0x111827,
        roughness: 0.6,
        metalness: 0.05
      });
      const browL = new THREE.Mesh(geoBrow, browMat);
      const browR = new THREE.Mesh(geoBrow, browMat);
      browL.position.set(-separation, 0.2, 0.44);
      browR.position.set(separation, 0.2, 0.44);

      // BOCA (ShapeGeometry)
      const mouthShape = new THREE.Shape();
      const mouthWidth = 0.5;
      let arcHeight = 0;
      let mouthOpen = 0.03;

      switch (expresion) {
        case 'alegre':
          arcHeight = 0.13;
          mouthOpen = 0.07;
          break;
        case 'triste':
          arcHeight = -0.15;
          mouthOpen = 0.03;
          break;
        case 'enojada':
          arcHeight = -0.07;
          mouthOpen = 0.02;
          break;
        case 'picara':
          arcHeight = 0.11;
          mouthOpen = 0.05;
          break;
        case 'malvada':
          arcHeight = 0.06;
          mouthOpen = 0.035;
          break;
        case 'neutra':
        default:
          arcHeight = 0.0;
          mouthOpen = 0.025;
          break;
      }

      mouthShape.moveTo(-mouthWidth / 2, 0);
      mouthShape.quadraticCurveTo(0, arcHeight, mouthWidth / 2, 0);
      mouthShape.quadraticCurveTo(0, arcHeight - mouthOpen, -mouthWidth / 2, 0);

      const mouthGeo = new THREE.ShapeGeometry(mouthShape);
      const mouthColor =
        expresion === 'malvada'
          ? 0x7f1d1d
          : expresion === 'triste'
          ? 0xf97373
          : 0xfb7185;

      const mouthMat = new THREE.MeshStandardMaterial({
        color: mouthColor,
        roughness: 0.4,
        metalness: 0.1,
        side: THREE.DoubleSide
      });

      const mouth = new THREE.Mesh(mouthGeo, mouthMat);
      mouth.position.set(0, -0.12, 0.44);

      function setLidAndBrow(openFactor, browTilt, browOffsetY, asymmetry = 0) {
        const topScaleY = 1.2 - openFactor * 0.7;
        const bottomScaleY = 0.4 + openFactor * 0.7;

        topLidL.scale.y = topScaleY;
        topLidR.scale.y = topScaleY;
        bottomLidL.scale.y = bottomScaleY;
        bottomLidR.scale.y = bottomScaleY;

        browL.position.y = 0.2 + browOffsetY;
        browR.position.y = 0.2 + browOffsetY - asymmetry * 0.04;

        browL.rotation.z = browTilt;
        browR.rotation.z = -browTilt + asymmetry * 0.15;
      }

      switch (expresion) {
        case 'alegre':
          setLidAndBrow(0.85, 0.12, 0.02, 0.06);
          break;
        case 'triste':
          setLidAndBrow(0.45, -0.25, -0.015);
          break;
        case 'enojada':
          setLidAndBrow(0.6, -0.4, -0.02);
          break;
        case 'picara':
          setLidAndBrow(0.75, 0.05, 0.03, 0.28);
          mouth.position.x = 0.03;
          break;
        case 'malvada':
          setLidAndBrow(0.55, -0.45, -0.03, 0.2);
          break;
        case 'neutra':
        default:
          setLidAndBrow(0.7, 0.0, 0.0);
          break;
      }

      head.add(topLidL, topLidR, bottomLidL, bottomLidR);
      head.add(browL, browR);
      head.add(mouth);
    }

    // === CONSTRUCTOR DE MU√ëECO HUMANO V2 ===
    function crearMunecoDesdeUI() {
      const tipoPersona = tipoPersonaEl.value;
      const ropaColor = new THREE.Color(colorRopaEl.value);
      const ojosTamKey = tamOjosEl.value;
      const ojosColorKey = colorOjosEl.value;
      const hairMat = CABELLO_COLOR[colorCabelloEl.value];
      const largoCabello = largoCabelloEl.value;
      const alturaBase = ESTATURA[estaturaEl.value];
      const anchoBase = CONTEXTURA[contexturaEl.value];
      const expresion = expresionEl.value;

      const group = new THREE.Group();
      group.userData.baseHeight = 0;

      // BASE
      const base = new THREE.Mesh(geoBaseDisc, matBase);
      base.position.y = 0.04;
      base.receiveShadow = true;
      group.add(base);

      // TIPO
      let skinMat = matSkin;
      let isFemale = false;
      let isChild = false;
      let isElder = false;

      if (tipoPersona === 'adulto_mujer' || tipoPersona === 'nina' || tipoPersona === 'anciano_mujer') {
        isFemale = true;
      }
      if (tipoPersona === 'nino' || tipoPersona === 'nina') {
        isChild = true;
      }
      if (tipoPersona === 'anciano_hombre' || tipoPersona === 'anciano_mujer') {
        isElder = true;
        skinMat = matSkinDark;
      }

      // CUERPO (grupo central)
      const rig = new THREE.Group();
      rig.position.y = 0.08; // encima de la base
      group.add(rig);

      // PELVIS
      const pelvis = new THREE.Mesh(geoPelvis, new THREE.MeshStandardMaterial({
        color: ropaColor,
        roughness: 0.8,
        metalness: 0.05
      }));
      pelvis.position.y = 0.7;
      pelvis.castShadow = true;
      pelvis.receiveShadow = true;
      rig.add(pelvis);

      // TORSO
      const torso = new THREE.Mesh(geoTorso, new THREE.MeshStandardMaterial({
        color: ropaColor.clone().offsetHSL(0, 0, 0.05),
        roughness: 0.8,
        metalness: 0.05
      }));
      torso.position.y = 1.35;
      torso.castShadow = true;
      torso.receiveShadow = true;
      rig.add(torso);

      // PECHO + CINTURA (ligeras curvas para mujer)
      if (isFemale && !isChild) {
        torso.scale.set(0.9, 1.0, 0.9);
        pelvis.scale.set(1.05, 1.0, 1.0);
      }

      // CUELLO
      const neck = new THREE.Mesh(geoNeck, new THREE.MeshStandardMaterial({
        color: skinMat.color,
        roughness: 0.6,
        metalness: 0.1
      }));
      neck.position.y = 1.9;
      neck.castShadow = true;
      rig.add(neck);

      // CABEZA
      const head = new THREE.Mesh(geoHead, skinMat);
      head.position.y = 2.35;
      head.castShadow = true;
      rig.add(head);

      // PROPORCI√ìN CABEZA PARA NI√ëOS
      if (isChild) {
        head.scale.set(1.15, 1.15, 1.15);
      }

      // CABELLO
      const hairCap = new THREE.Mesh(geoHairCap, hairMat);
      hairCap.castShadow = true;
      if (largoCabello === 'corto') {
        hairCap.scale.set(1.0, 0.7, 1.0);
      } else if (largoCabello === 'medio') {
        hairCap.scale.set(1.05, 1.0, 1.05);
      } else {
        hairCap.scale.set(1.05, 1.2, 1.08);
        const backHair = new THREE.Mesh(geoHairBack, hairMat);
        backHair.position.set(0, -0.1, -0.3);
        backHair.scale.set(1.0, 1.1, 1.0);
        backHair.castShadow = true;
        head.add(backHair);
      }
      hairCap.position.y = 0.08;
      head.add(hairCap);

      // CARA
      addFaceDetails(head, {
        ojosTamKey,
        ojosColorKey,
        expresion
      });

      // NARIZ
      const nose = new THREE.Mesh(
        geoNose,
        new THREE.MeshStandardMaterial({
          color: 0xe5e7eb,
          roughness: 0.6,
          metalness: 0.05
        })
      );
      nose.position.set(0, 2.25, 0.47);
      rig.add(nose);

      // BRAZOS
      const armMat = new THREE.MeshStandardMaterial({
        color: ropaColor.clone().offsetHSL(0, 0, -0.02),
        roughness: 0.85,
        metalness: 0.05
      });
      const skinHandMat = skinMat;

      function createArm(side = 1) {
        const armGroup = new THREE.Group();

        const upper = new THREE.Mesh(geoUpperArm, armMat);
        upper.position.y = -0.25;
        upper.castShadow = true;
        upper.receiveShadow = true;

        const lower = new THREE.Mesh(geoLowerArm, armMat);
        lower.position.y = -0.55;
        lower.castShadow = true;
        lower.receiveShadow = true;

        const hand = new THREE.Mesh(geoHand, skinHandMat);
        hand.position.y = -0.88;
        hand.castShadow = true;
        hand.receiveShadow = true;

        armGroup.add(upper);
        armGroup.add(lower);
        armGroup.add(hand);

        armGroup.position.set(0.45 * side, 1.6, 0);
        armGroup.rotation.z = THREE.MathUtils.degToRad(15 * side);
        armGroup.rotation.x = THREE.MathUtils.degToRad(5);

        return armGroup;
      }

      const leftArm = createArm(-1);
      const rightArm = createArm(1);
      rig.add(leftArm, rightArm);

      // PIERNAS
      const legMat = new THREE.MeshStandardMaterial({
        color: ropaColor.clone().offsetHSL(0, 0, -0.08),
        roughness: 0.85,
        metalness: 0.05
      });
      const shoeMat = new THREE.MeshStandardMaterial({
        color: 0x111827,
        roughness: 0.7,
        metalness: 0.15
      });

      function createLeg(side = 1) {
        const legGroup = new THREE.Group();

        const thigh = new THREE.Mesh(geoThigh, legMat);
        thigh.position.y = -0.35;
        thigh.castShadow = true;
        thigh.receiveShadow = true;

        const calf = new THREE.Mesh(geoCalf, legMat);
        calf.position.y = -0.95;
        calf.castShadow = true;
        calf.receiveShadow = true;

        const foot = new THREE.Mesh(geoFoot, shoeMat);
        foot.position.y = -1.35;
        foot.position.z = 0.08;
        foot.castShadow = true;
        foot.receiveShadow = true;

        legGroup.add(thigh);
        legGroup.add(calf);
        legGroup.add(foot);

        legGroup.position.set(0.18 * side, 0.7, 0);
        legGroup.rotation.x = THREE.MathUtils.degToRad(3);

        return legGroup;
      }

      const leftLeg = createLeg(-1);
      const rightLeg = createLeg(1);
      rig.add(leftLeg, rightLeg);

      // LIGERA POSTURA PARA ANCIANOS
      if (isElder) {
        rig.rotation.x = THREE.MathUtils.degToRad(-6);
        head.position.y += 0.05;
      }

      // ESCALA GLOBAL
      let sY = alturaBase;
      if (isChild) sY = 0.7;
      if (isElder) sY *= 0.95;

      const sXZ = anchoBase;
      rig.scale.set(sXZ, sY, sXZ);

      // POSICI√ìN INICIAL
      const angle = Math.random() * Math.PI * 2;
      const r = 1 + Math.random() * 4;
      group.position.set(Math.cos(angle) * r, 0, Math.sin(angle) * r);

      scene.add(group);
      objects.push(group);
      selectObject(group);
    }

    // === BOTONES ===
    btnCrear.addEventListener('click', () => {
      crearMunecoDesdeUI();
    });

    btnFoto.addEventListener('click', () => {
      renderer.render(scene, camera);
      const link = document.createElement('a');
      link.download = 'munecos-humanos-v2-' + new Date().toISOString().slice(0, 10) + '.png';
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    });

    function deleteSelected() {
      if (selectedObject) {
        if (selectionHelper) {
          scene.remove(selectionHelper);
          selectionHelper = null;
        }
        scene.remove(selectedObject);
        const idx = objects.indexOf(selectedObject);
        if (idx > -1) objects.splice(idx, 1);
        selectedObject = null;
      }
    }

    btnBorrar.addEventListener('click', deleteSelected);
    const btnDeleteFloating = document.getElementById('btnDeleteFloating');
    btnDeleteFloating.addEventListener('click', deleteSelected);

    btnReset.addEventListener('click', () => {
      if (!confirm('¬øLimpiar toda la escena?')) return;
      for (const obj of objects) scene.remove(obj);
      objects = [];
      selectedObject = null;
      if (selectionHelper) {
        scene.remove(selectionHelper);
        selectionHelper = null;
      }
    });

    // === RESIZE ===
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    window.addEventListener('keydown', (e) => {
      const activeTag = document.activeElement?.tagName;
      if (['INPUT', 'SELECT', 'TEXTAREA'].includes(activeTag)) return;

      if (e.key === 'Delete' || e.key === 'Backspace') {
        deleteSelected();
      }
      if (e.key.toLowerCase() === 'r' && selectedObject) {
        selectedObject.rotation.y += Math.PI / 8;
      }
    });

    // === LOOP ===
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (selectionHelper && selectedObject) {
        selectionHelper.update();
      }
      renderer.render(scene, camera);
    }

    // === INIT ===
    function init() {
      initThree();
      setupLights();
      createRoom();
      setupInteraction();
      actualizarResumenConfig();
      // Crear uno de ejemplo
      crearMunecoDesdeUI();
      animate();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
