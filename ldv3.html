<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LEGO Facial Expressions PRO - Expresiones Hiper-Realistas</title>

  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --surface: rgba(255, 255, 255, 0.95);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: linear-gradient(135deg, #e0e7ff 0%, #f3e8ff 100%);
      color: #1e293b;
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #app {
      display: flex;
      height: 100%;
      width: 100%;
    }

    /* --- SIDEBAR --- */
    #sidebar {
      width: 380px;
      min-width: 340px;
      height: 100%;
      background: var(--surface);
      padding: 25px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 25px;
      box-shadow: 10px 0 30px rgba(0,0,0,0.1);
      z-index: 10;
    }

    .logo {
      text-align: center;
      padding-bottom: 15px;
      border-bottom: 2px solid rgba(99, 102, 241, 0.1);
    }

    h1 {
      font-size: 1.8rem;
      color: var(--primary);
      margin-bottom: 5px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    h2.subtitle {
      font-size: 0.9rem;
      color: #64748b;
      font-weight: 500;
    }

    .control-group {
      background: rgba(255,255,255,0.7);
      padding: 20px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.8);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    }

    .section-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--primary);
      margin-bottom: 15px;
      font-weight: 700;
      display: flex; align-items: center; gap: 8px;
    }

    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 8px;
      font-weight: 600;
      color: #475569;
    }

    select {
      width: 100%;
      padding: 12px 15px;
      border-radius: 12px;
      border: 2px solid #e2e8f0;
      background: #fff;
      font-size: 0.95rem;
      outline: none;
      transition: all 0.3s;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%236366f1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 15px center;
      background-size: 18px;
      font-weight: 500;
    }

    select:focus { 
      border-color: var(--primary); 
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }

    .grid-2 { 
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 15px; 
    }

    .grid-3 { 
      display: grid; 
      grid-template-columns: repeat(3, 1fr); 
      gap: 12px; 
    }

    /* --- BOTONES --- */
    button {
      width: 100%;
      padding: 15px;
      border-radius: 14px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.95rem;
      display: flex; 
      align-items: center; 
      justify-content: center; 
      gap: 10px;
    }
    
    button:hover { transform: translateY(-2px); }
    button:active { transform: scale(0.98); }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      color: white;
      box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.4);
    }
    .btn-primary:hover { 
      box-shadow: 0 15px 35px -8px rgba(99, 102, 241, 0.5); 
    }
    
    .btn-secondary { 
      background: #f1f5f9; 
      color: #475569; 
      border: 2px solid #e2e8f0; 
    }
    .btn-secondary:hover { background: #e2e8f0; }

    .btn-danger { 
      background: #fef2f2; 
      color: #dc2626; 
      border: 2px solid #fee2e2; 
    }
    .btn-danger:hover { background: #fee2e2; }
    
    /* --- CANVAS --- */
    #canvas-container {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at 50% 30%, #ffffff 0%, #f1f5f9 60%, #e2e8f0 100%);
      cursor: grab;
      overflow: hidden;
    }
    
    #canvas-container:active { cursor: grabbing; }

    /* --- UI FLOTANTE --- */
    #selection-ui {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%) translateY(200%);
      background: rgba(255, 255, 255, 0.98);
      padding: 18px 30px;
      border-radius: 20px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 25px;
      transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 20;
      opacity: 0;
      border: 1px solid rgba(255,255,255,0.5);
      backdrop-filter: blur(10px);
    }
    
    #selection-ui.active { 
      transform: translateX(-50%) translateY(0); 
      opacity: 1; 
    }

    .rotation-control { 
      display: flex; 
      align-items: center; 
      gap: 15px; 
      color: #475569; 
      font-weight: 600;
    }
    
    input[type=range] { 
      width: 140px; 
      accent-color: var(--primary); 
    }

    #instructions {
      position: absolute; 
      top: 25px; 
      right: 25px;
      background: rgba(255,255,255,0.85);
      padding: 12px 20px;
      border-radius: 20px; 
      font-size: 0.8rem;
      color: #475569; 
      font-weight: 600;
      box-shadow: 0 8px 25px rgba(0,0,0,0.08);
      pointer-events: none;
      max-width: 300px;
      line-height: 1.5;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255,255,255,0.5);
    }

    /* --- EXPRESSION GALLERY --- */
    .expressions-gallery {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-top: 15px;
    }
    
    .expression-tile {
      aspect-ratio: 1;
      background: linear-gradient(135deg, #f8fafc, #f1f5f9);
      border: 3px solid #e2e8f0;
      border-radius: 14px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      padding: 12px;
    }
    
    .expression-tile:hover {
      transform: translateY(-4px);
      border-color: var(--primary);
      box-shadow: 0 12px 25px rgba(99, 102, 241, 0.2);
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
    }
    
    .expression-tile.active {
      border-color: var(--primary);
      background: linear-gradient(135deg, #dbeafe, #bfdbfe);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.15), 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    .expression-emoji {
      font-size: 2rem;
      margin-bottom: 8px;
      transition: transform 0.3s;
    }
    
    .expression-tile:hover .expression-emoji {
      transform: scale(1.2);
    }
    
    .expression-name {
      font-size: 0.75rem;
      font-weight: 700;
      color: #334155;
      text-align: center;
      line-height: 1.2;
    }

    .color-preview {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: inline-block;
      margin-left: 8px;
      border: 2px solid #e2e8f0;
      vertical-align: middle;
    }

    /* Tipo de cabello preview */
    .hair-type-preview {
      display: inline-block;
      font-size: 1.2rem;
      margin-left: 8px;
      vertical-align: middle;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>

<div id="app">
  <aside id="sidebar">
    <div class="logo">
      <h1>LEGO EXPRESSIONS PRO</h1>
      <h2 class="subtitle">Expresiones Faciales - Fenotipo Occidental</h2>
    </div>
    
    <div class="control-group">
      <div class="section-title">ğŸ‘¤ IDENTIDAD DEL PERSONAJE</div>
      
      <div class="grid-2">
        <div>
          <label>GÃ©nero</label>
          <select id="genero">
            <option value="hombre">ğŸ‘¨ Hombre</option>
            <option value="mujer" selected>ğŸ‘© Mujer</option>
          </select>
        </div>
        <div>
          <label>Edad</label>
          <select id="edad">
            <option value="nino">ğŸ‘¦ NiÃ±o/NiÃ±a (5-12)</option>
            <option value="joven" selected>ğŸ§’ Joven (13-25)</option>
            <option value="adulto">ğŸ§‘ Adulto (26-59)</option>
            <option value="anciano">ğŸ§“ Anciano (60+)</option>
          </select>
        </div>
      </div>
      
      <div style="margin-top:20px;">
        <label>Fenotipo</label>
        <select id="fenotipo">
          <option value="nordico" selected>ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ NÃ³rdico (Piel muy clara)</option>
          <option value="mediterraneo">ğŸ‡®ğŸ‡¹ MediterrÃ¡neo (Piel clara-oliva)</option>
          <option value="centroeuropeo">ğŸ‡©ğŸ‡ª Centro Europeo (Piel intermedia)</option>
          <option value="britanico">ğŸ‡¬ğŸ‡§ BritÃ¡nico (Piel rosada)</option>
          <option value="europeo_oriental">ğŸ‡µğŸ‡± Europeo Oriental</option>
        </select>
      </div>
    </div>

    <div class="control-group">
      <div class="section-title">ğŸ¨ APARIENCIA FÃSICA</div>
      
      <div class="grid-2">
        <div>
          <label>Tono de Piel <span id="pielPreview" class="color-preview"></span></label>
          <select id="colorPiel">
            <!-- Se llenarÃ¡ dinÃ¡micamente segÃºn fenotipo -->
          </select>
        </div>
        <div>
          <label>Color de Ojos <span id="ojosPreview" class="color-preview"></span></label>
          <select id="colorOjos">
            <!-- Se llenarÃ¡ dinÃ¡micamente segÃºn fenotipo -->
          </select>
        </div>
      </div>
      
      <div style="margin-top:20px;" class="grid-2">
        <div>
          <label>Tipo de Cabello <span id="hairTypePreview" class="hair-type-preview">ğŸ’‡</span></label>
          <select id="tipoCabello">
            <option value="lacio" selected>ğŸ’‡ Lacio/Directo</option>
            <option value="ondulado">ğŸŒŠ Ondulado</option>
            <option value="rizado">ğŸŒ€ Rizado</option>
            <option value="muy_rizado">ğŸŒ€ğŸŒ€ Muy Rizado</option>
            <option value="calvo">ğŸ‘¨â€ğŸ¦² Calvo</option>
          </select>
        </div>
        <div>
          <label>Color de Cabello <span id="peloPreview" class="color-preview"></span></label>
          <select id="colorCabello">
            <!-- Se llenarÃ¡ dinÃ¡micamente segÃºn fenotipo -->
          </select>
        </div>
      </div>
      
      <div style="margin-top:20px;">
        <label>Color de Ropa <span id="ropaPreview" class="color-preview"></span></label>
        <select id="colorRopa">
          <option value="#2563eb">ğŸ”µ Azul Real</option>
          <option value="#dc2626" selected>ğŸ”´ Rojo Intenso</option>
          <option value="#16a34a">ğŸŸ¢ Verde Esmeralda</option>
          <option value="#eab308">ğŸŸ¡ Amarillo Sol</option>
          <option value="#9333ea">ğŸŸ£ PÃºrpura Real</option>
          <option value="#0f172a">âš« Negro</option>
          <option value="#ffffff">âšª Blanco</option>
          <option value="#7c3aed">ğŸŸ£ Violeta</option>
          <option value="#ea580c">ğŸŸ  Naranja</option>
        </select>
      </div>
    </div>

    <div class="control-group" style="border: 2px solid var(--primary); background: rgba(99, 102, 241, 0.03);">
      <div class="section-title">ğŸ­ EXPRESIONES FACIALES</div>
      
      <label>SelecciÃ³n Principal</label>
      <select id="expresion">
        <option value="neutro">ğŸ˜ Neutro - Calmado</option>
        <option value="feliz" selected>ğŸ˜Š Feliz - Sonriente</option>
        <option value="muy_feliz">ğŸ˜‚ Muy Feliz - Riendo</option>
        <option value="triste">ğŸ˜¢ Triste - MelancÃ³lico</option>
        <option value="llorando">ğŸ˜­ Llorando - Devastado</option>
        <option value="enojado">ğŸ˜  Enojado - Irritado</option>
        <option value="furioso">ğŸ¤¬ Furioso - Iracundo</option>
        <option value="malvado">ğŸ˜ˆ Malvado - Siniestro</option>
        <option value="sorprendido">ğŸ˜® Sorprendido - Asombrado</option>
        <option value="asustado">ğŸ˜¨ Asustado - Temeroso</option>
        <option value="terror">ğŸ˜± Terror - PÃ¡nico</option>
        <option value="picaro">ğŸ˜ PÃ­caro - Malicioso</option>
        <option value="coqueto">ğŸ˜˜ Coqueto - Seductor</option>
        <option value="amor">ğŸ¥° Amor - CariÃ±oso</option>
        <option value="pensativo">ğŸ¤” Pensativo - Reflexivo</option>
        <option value="confundido">ğŸ˜• Confundido - Perplejo</option>
        <option value="desprecio">ğŸ˜’ Desprecio - DesdeÃ±oso</option>
        <option value="dolor">ğŸ˜– Dolor - Sufrimiento</option>
        <option value="cansado">ğŸ˜« Cansado - Agotado</option>
      </select>
      
      <div class="expressions-gallery" id="expressionsGallery">
        <!-- Se llenarÃ¡ con JavaScript -->
      </div>
      
      <div style="margin-top:20px;">
        <label>Intensidad de ExpresiÃ³n: <span id="intensidadValor">70%</span></label>
        <input type="range" id="intensidadExpresion" min="10" max="100" value="70">
      </div>
    </div>

    <button id="btnCrear" class="btn-primary">
      <span>âœ¨</span> CREAR PERSONAJE EXPRESIVO
    </button>
    
    <div style="margin-top: auto;">
      <div class="section-title">âš™ï¸ HERRAMIENTAS</div>
      <div class="grid-2">
        <button id="btnFoto" class="btn-secondary">
          <span>ğŸ“¸</span> CAPTURAR IMAGEN
        </button>
        <button id="btnReset" class="btn-danger">
          <span>ğŸ”¥</span> LIMPIAR ESCENA
        </button>
      </div>
      <div class="grid-2" style="margin-top:12px;">
        <button id="btnExpresionAleatoria" class="btn-secondary">
          <span>ğŸ²</span> EXPRESIÃ“N ALEATORIA
        </button>
        <button id="btnCopiar" class="btn-secondary">
          <span>ğŸ‘¯</span> CLONAR SELECCIONADO
        </button>
      </div>
    </div>
  </aside>

  <main id="canvas-container">
    <div id="instructions">
      ğŸ–±ï¸ Click para seleccionar personaje<br>
      ğŸ–±ï¸ Arrastra para mover en el escenario<br>
      ğŸ”„ Click largo para rotar 45Â°<br>
      ğŸ–±ï¸ Rueda del ratÃ³n para zoom in/out
    </div>
    
    <div id="selection-ui">
      <div class="rotation-control">
        <span>ROTACIÃ“N:</span>
        <input type="range" id="rotSlider" min="0" max="6.28" step="0.01" value="0">
        <span style="min-width:50px; text-align:center;" id="rotationValue">0Â°</span>
      </div>
      
      <div style="width:2px; height:40px; background:linear-gradient(to bottom, transparent, #e2e8f0, transparent); margin:0 20px;"></div>
      
      <button id="btnBorrarSel" style="background: linear-gradient(135deg, #fee2e2, #fecaca); color: #dc2626; border:none; padding:12px 24px; border-radius:12px; cursor:pointer; font-weight:700; display:flex; align-items:center; gap:10px; min-width:140px;">
        <span>ğŸ—‘ï¸</span> ELIMINAR
      </button>
    </div>
  </main>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // === CONFIGURACIÃ“N ===
  const CONFIG = {
    faceResolution: 1024,
    shadowQuality: 4096,
    maxCharacters: 15,
    plasticRoughness: 0.25,
    plasticMetalness: 0.08
  };

  // === FENOTIPOS OCCIDENTALES ===
  const FENOTIPOS = {
    nordico: {
      name: "NÃ³rdico",
      skinTones: [
        { value: '#ffebd6', name: 'Muy Claro Rosado' },
        { value: '#f8d9b7', name: 'Claro Lechoso' },
        { value: '#f1c27d', name: 'Beige Claro' },
        { value: '#e6b17e', name: 'Beige Rosado' }
      ],
      hairColors: [
        { value: '#fbbf24', name: 'Rubio Platino' },
        { value: '#f59e0b', name: 'Rubio Dorado' },
        { value: '#d97706', name: 'Rubio Oscuro' },
        { value: '#92400e', name: 'Pelirrojo' },
        { value: '#78350f', name: 'CastaÃ±o Claro' },
        { value: '#fef3c7', name: 'Rubio Muy Claro' }
      ],
      eyeColors: [
        { value: '#1e40af', name: 'Azul Intenso' },
        { value: '#3b82f6', name: 'Azul Claro' },
        { value: '#0ea5e9', name: 'Azul GrisÃ¡ceo' },
        { value: '#0891b2', name: 'Azul Verde' },
        { value: '#0d9488', name: 'Verde Azulado' }
      ]
    },
    mediterraneo: {
      name: "MediterrÃ¡neo",
      skinTones: [
        { value: '#e6b17e', name: 'Oliva Claro' },
        { value: '#d4a574', name: 'Oliva Medio' },
        { value: '#c19a6b', name: 'Oliva Oscuro' },
        { value: '#b08d57', name: 'Bronceado' }
      ],
      hairColors: [
        { value: '#92400e', name: 'CastaÃ±o Oscuro' },
        { value: '#78350f', name: 'CastaÃ±o Medio' },
        { value: '#451a03', name: 'Negro Azabache' },
        { value: '#7c2d12', name: 'Pelirrojo Oscuro' },
        { value: '#d97706', name: 'CastaÃ±o Dorado' }
      ],
      eyeColors: [
        { value: '#78350f', name: 'MarrÃ³n Oscuro' },
        { value: '#92400e', name: 'MarrÃ³n' },
        { value: '#b45309', name: 'MarrÃ³n Claro' },
        { value: '#0d9488', name: 'Verde' },
        { value: '#0f766e', name: 'Verde Oscuro' }
      ]
    },
    centroeuropeo: {
      name: "Centro Europeo",
      skinTones: [
        { value: '#f1c27d', name: 'Beige' },
        { value: '#e6b17e', name: 'Beige Rosado' },
        { value: '#d4a574', name: 'Beige Medio' },
        { value: '#c19a6b', name: 'Beige Oscuro' }
      ],
      hairColors: [
        { value: '#78350f', name: 'CastaÃ±o' },
        { value: '#92400e', name: 'CastaÃ±o Oscuro' },
        { value: '#451a03', name: 'Negro' },
        { value: '#d97706', name: 'Rubio Oscuro' },
        { value: '#f59e0b', name: 'Rubio' }
      ],
      eyeColors: [
        { value: '#3b82f6', name: 'Azul' },
        { value: '#0ea5e9', name: 'Azul Gris' },
        { value: '#78350f', name: 'MarrÃ³n' },
        { value: '#0d9488', name: 'Verde' },
        { value: '#64748b', name: 'Gris' }
      ]
    },
    britanico: {
      name: "BritÃ¡nico",
      skinTones: [
        { value: '#ffdbac', name: 'Rosado Muy Claro' },
        { value: '#f8d9b7', name: 'Rosado Claro' },
        { value: '#f1c27d', name: 'Rosado Medio' },
        { value: '#e6b17e', name: 'Rosado Oscuro' }
      ],
      hairColors: [
        { value: '#fef3c7', name: 'Rubio Muy Claro' },
        { value: '#fbbf24', name: 'Rubio' },
        { value: '#d97706', name: 'Rubio Oscuro' },
        { value: '#92400e', name: 'Pelirrojo' },
        { value: '#78350f', name: 'CastaÃ±o' }
      ],
      eyeColors: [
        { value: '#1e40af', name: 'Azul Real' },
        { value: '#3b82f6', name: 'Azul Claro' },
        { value: '#0ea5e9', name: 'Azul Gris' },
        { value: '#0891b2', name: 'Azul Verde' },
        { value: '#64748b', name: 'Gris Azulado' }
      ]
    },
    europeo_oriental: {
      name: "Europeo Oriental",
      skinTones: [
        { value: '#f1c27d', name: 'Beige Claro' },
        { value: '#e6b17e', name: 'Beige' },
        { value: '#d4a574', name: 'Beige Medio' },
        { value: '#c19a6b', name: 'Beige Oscuro' }
      ],
      hairColors: [
        { value: '#451a03', name: 'Negro' },
        { value: '#1c1917', name: 'Negro Azabache' },
        { value: '#78350f', name: 'CastaÃ±o Oscuro' },
        { value: '#92400e', name: 'CastaÃ±o' },
        { value: '#d97706', name: 'CastaÃ±o Claro' }
      ],
      eyeColors: [
        { value: '#78350f', name: 'MarrÃ³n' },
        { value: '#92400e', name: 'MarrÃ³n Medio' },
        { value: '#b45309', name: 'MarrÃ³n Claro' },
        { value: '#0f766e', name: 'Verde Oscuro' },
        { value: '#1e40af', name: 'Azul' }
      ]
    }
  };

  // === VARIABLES GLOBALES ===
  const container = document.getElementById('canvas-container');
  const uiSelection = document.getElementById('selection-ui');
  const rotSlider = document.getElementById('rotSlider');
  const rotationValue = document.getElementById('rotationValue');
  const expressionsGallery = document.getElementById('expressionsGallery');
  const intensidadSlider = document.getElementById('intensidadExpresion');
  const intensidadValor = document.getElementById('intensidadValor');
  const pielPreview = document.getElementById('pielPreview');
  const ropaPreview = document.getElementById('ropaPreview');
  const peloPreview = document.getElementById('peloPreview');
  const ojosPreview = document.getElementById('ojosPreview');
  const hairTypePreview = document.getElementById('hairTypePreview');
  const fenotipoSelect = document.getElementById('fenotipo');
  const tipoCabelloSelect = document.getElementById('tipoCabello');
  
  let scene, camera, renderer, controls, raycaster, mouse;
  let characters = []; 
  let selectedCharacter = null;
  let selectionRing = null;
  let isDragging = false;
  let draggedCharacter = null;
  const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  const dragBoundsRaycaster = new THREE.Raycaster();

  // === EXPRESIONES DISPONIBLES ===
  const EXPRESSIONS = [
    { id: 'neutro', emoji: 'ğŸ˜', name: 'Neutro', color: '#94a3b8' },
    { id: 'feliz', emoji: 'ğŸ˜Š', name: 'Feliz', color: '#fbbf24' },
    { id: 'muy_feliz', emoji: 'ğŸ˜‚', name: 'Muy Feliz', color: '#f59e0b' },
    { id: 'triste', emoji: 'ğŸ˜¢', name: 'Triste', color: '#60a5fa' },
    { id: 'llorando', emoji: 'ğŸ˜­', name: 'Llorando', color: '#3b82f6' },
    { id: 'enojado', emoji: 'ğŸ˜ ', name: 'Enojado', color: '#ef4444' },
    { id: 'furioso', emoji: 'ğŸ¤¬', name: 'Furioso', color: '#dc2626' },
    { id: 'malvado', emoji: 'ğŸ˜ˆ', name: 'Malvado', color: '#7c3aed' },
    { id: 'sorprendido', emoji: 'ğŸ˜®', name: 'Sorprendido', color: '#8b5cf6' },
    { id: 'asustado', emoji: 'ğŸ˜¨', name: 'Asustado', color: '#6366f1' },
    { id: 'terror', emoji: 'ğŸ˜±', name: 'Terror', color: '#4f46e5' },
    { id: 'picaro', emoji: 'ğŸ˜', name: 'PÃ­caro', color: '#10b981' },
    { id: 'coqueto', emoji: 'ğŸ˜˜', name: 'Coqueto', color: '#ec4899' },
    { id: 'amor', emoji: 'ğŸ¥°', name: 'Amor', color: '#f472b6' },
    { id: 'pensativo', emoji: 'ğŸ¤”', name: 'Pensativo', color: '#6b7280' },
    { id: 'confundido', emoji: 'ğŸ˜•', name: 'Confundido', color: '#9ca3af' },
    { id: 'desprecio', emoji: 'ğŸ˜’', name: 'Desprecio', color: '#57534e' },
    { id: 'dolor', emoji: 'ğŸ˜–', name: 'Dolor', color: '#b91c1c' },
    { id: 'cansado', emoji: 'ğŸ˜«', name: 'Cansado', color: '#78716c' }
  ];

  // === TIPOS DE CABELLO - GEOMETRÃAS ===
  const HAIR_TYPES = {
    lacio: {
      geometry: (isFemale, isChild) => {
        if (isFemale && !isChild) {
          return new THREE.CylinderGeometry(1.1, 1.1, 0.8, 16);
        }
        return new THREE.BoxGeometry(2.3, 0.6, 2.3);
      },
      scale: { x: 1, y: 1, z: 1 },
      rotation: { x: 0, y: 0, z: 0 },
      position: { y: 0.9, z: 0 }
    },
    ondulado: {
      geometry: (isFemale, isChild) => {
        const geo = new THREE.CylinderGeometry(1.1, 1.1, 0.9, 16);
        // Agregar ondulaciÃ³n
        const position = geo.attributes.position;
        for (let i = 0; i < position.count; i++) {
          const x = position.getX(i);
          const y = position.getY(i);
          const z = position.getZ(i);
          if (Math.abs(y) > 0.2) {
            const wave = Math.sin(y * 10) * 0.1;
            position.setZ(i, z + wave);
          }
        }
        position.needsUpdate = true;
        return geo;
      },
      scale: { x: 1.05, y: 1.1, z: 1.05 },
      rotation: { x: 0, y: 0, z: 0 },
      position: { y: 0.9, z: 0 }
    },
    rizado: {
      geometry: (isFemale, isChild) => {
        // Cabello rizado con mÃºltiples anillos
        const group = new THREE.Group();
        
        // Base del cabello
        const base = new THREE.Mesh(
          new THREE.SphereGeometry(1.2, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2),
          new THREE.MeshStandardMaterial()
        );
        base.position.y = 0.4;
        base.scale.set(1, 0.3, 1);
        group.add(base);
        
        // Rizos adicionales
        const ringCount = 4;
        for (let i = 0; i < ringCount; i++) {
          const ring = new THREE.Mesh(
            new THREE.TorusGeometry(1.1 - i * 0.2, 0.08, 8, 16),
            new THREE.MeshStandardMaterial()
          );
          ring.position.y = 0.2 + i * 0.1;
          ring.rotation.x = Math.PI / 2;
          group.add(ring);
        }
        
        return group;
      },
      scale: { x: 1.1, y: 1.2, z: 1.1 },
      rotation: { x: 0, y: 0, z: 0 },
      position: { y: 0.8, z: 0 }
    },
    muy_rizado: {
      geometry: (isFemale, isChild) => {
        // Cabello muy rizado/afro
        const group = new THREE.Group();
        
        // Base esfÃ©rica para afro
        const afroBase = new THREE.Mesh(
          new THREE.SphereGeometry(1.3, 32, 24),
          new THREE.MeshStandardMaterial()
        );
        afroBase.scale.set(1, 0.7, 1);
        afroBase.position.y = 0.3;
        group.add(afroBase);
        
        // Textura de bultos para efecto afro
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const radius = 0.9;
          const bump = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 8, 6),
            new THREE.MeshStandardMaterial()
          );
          bump.position.set(
            Math.cos(angle) * radius,
            0.4 + Math.sin(i * 0.5) * 0.1,
            Math.sin(angle) * radius
          );
          group.add(bump);
        }
        
        return group;
      },
      scale: { x: 1.2, y: 1.3, z: 1.2 },
      rotation: { x: 0, y: 0, z: 0 },
      position: { y: 0.7, z: 0 }
    },
    calvo: {
      geometry: () => {
        // Para calvicie, geometrÃ­a muy simple o inexistente
        const group = new THREE.Group();
        
        // PequeÃ±o anillo para calvicie incipiente
        if (Math.random() > 0.5) {
          const ring = new THREE.Mesh(
            new THREE.RingGeometry(0.8, 1.1, 16),
            new THREE.MeshStandardMaterial()
          );
          ring.rotation.x = -Math.PI / 2;
          ring.position.y = 0.1;
          group.add(ring);
        }
        
        return group;
      },
      scale: { x: 1, y: 1, z: 1 },
      rotation: { x: 0, y: 0, z: 0 },
      position: { y: 0.1, z: 0 }
    }
  };

  // === FUNCIONES DE INICIALIZACIÃ“N ===
  function init() {
    // Inicializar Three.js
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xe2e8f0, 50, 150);

    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 25, 50);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      preserveDrawingBuffer: true, 
      alpha: true 
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 100;
    controls.enablePan = true;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Setup
    setupEnvironment();
    createSelectionRing();
    setupUI();
    setupInteraction();

    // Cargar fenotipo inicial
    loadFenotipo('nordico');

    // Crear personaje inicial
    createCharacter({ x: 0, z: 0 });

    animate();
  }

  function setupEnvironment() {
    // Luces principales
    const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
    scene.add(ambient);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
    mainLight.position.set(30, 50, 30);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(CONFIG.shadowQuality, CONFIG.shadowQuality);
    mainLight.shadow.camera.left = -50;
    mainLight.shadow.camera.right = 50;
    mainLight.shadow.camera.top = 50;
    mainLight.shadow.camera.bottom = -50;
    mainLight.shadow.bias = -0.001;
    mainLight.shadow.radius = 4;
    scene.add(mainLight);
    
    const fillLight = new THREE.DirectionalLight(0xfff9db, 0.8);
    fillLight.position.set(-30, 20, 30);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0x6366f1, 0.6);
    rimLight.position.set(0, 25, -40);
    scene.add(rimLight);

    // Suelo con sombras suaves
    const planeGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.ShadowMaterial({ 
      opacity: 0.25,
      color: 0x000000
    });
    const floorMesh = new THREE.Mesh(planeGeo, floorMat);
    floorMesh.rotation.x = -Math.PI/2;
    floorMesh.receiveShadow = true;
    floorMesh.position.y = 0.01;
    scene.add(floorMesh);

    // Grid decorativo
    const grid = new THREE.GridHelper(200, 100, 0x94a3b8, 0xe2e8f0);
    grid.material.opacity = 0.3;
    grid.material.transparent = true;
    grid.position.y = 0.02;
    scene.add(grid);
  }

  function createSelectionRing() {
    const geometry = new THREE.TorusGeometry(1.8, 0.08, 16, 64);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0x6366f1, 
      transparent: true, 
      opacity: 0.9 
    });
    selectionRing = new THREE.Mesh(geometry, material);
    selectionRing.rotation.x = -Math.PI / 2;
    selectionRing.visible = false;
    scene.add(selectionRing);
  }

  function setupUI() {
    // Llenar galerÃ­a de expresiones
    expressionsGallery.innerHTML = '';
    EXPRESSIONS.forEach(expr => {
      const tile = document.createElement('div');
      tile.className = 'expression-tile';
      tile.style.borderColor = expr.color;
      tile.innerHTML = `
        <div class="expression-emoji">${expr.emoji}</div>
        <div class="expression-name">${expr.name}</div>
      `;
      tile.addEventListener('click', () => {
        document.getElementById('expresion').value = expr.id;
        // Actualizar UI
        document.querySelectorAll('.expression-tile').forEach(t => t.classList.remove('active'));
        tile.classList.add('active');
        // Si hay un personaje seleccionado, actualizar su expresiÃ³n
        if (selectedCharacter) {
          updateCharacterExpression(selectedCharacter, expr.id);
        }
      });
      expressionsGallery.appendChild(tile);
    });

    // Inicializar con expresiÃ³n feliz seleccionada
    const felizTile = expressionsGallery.querySelector('.expression-tile:nth-child(2)');
    if (felizTile) felizTile.classList.add('active');

    // Actualizar valor de intensidad
    intensidadSlider.addEventListener('input', (e) => {
      const value = e.target.value;
      intensidadValor.textContent = `${value}%`;
      if (selectedCharacter) {
        updateCharacterExpression(selectedCharacter, selectedCharacter.userData.expresion, value);
      }
    });

    // Actualizar slider de rotaciÃ³n
    rotSlider.addEventListener('input', (e) => {
      const radians = parseFloat(e.target.value);
      const degrees = Math.round(radians * 180 / Math.PI);
      rotationValue.textContent = `${degrees}Â°`;
      if (selectedCharacter) {
        selectedCharacter.rotation.y = radians;
      }
    });

    // Actualizar preview de tipo de cabello
    tipoCabelloSelect.addEventListener('change', function() {
      const emojis = {
        lacio: 'ğŸ’‡',
        ondulado: 'ğŸŒŠ',
        rizado: 'ğŸŒ€',
        muy_rizado: 'ğŸŒ€ğŸŒ€',
        calvo: 'ğŸ‘¨â€ğŸ¦²'
      };
      hairTypePreview.textContent = emojis[this.value] || 'ğŸ’‡';
    });

    // Cargar fenotipo cuando cambia
    fenotipoSelect.addEventListener('change', function() {
      loadFenotipo(this.value);
    });
  }

  function loadFenotipo(fenotipoId) {
    const fenotipo = FENOTIPOS[fenotipoId];
    if (!fenotipo) return;

    // Actualizar tÃ­tulo del fenotipo
    document.querySelector('h2.subtitle').textContent = 
      `Expresiones Faciales - Fenotipo ${fenotipo.name}`;

    // Llenar opciones de piel
    const pielSelect = document.getElementById('colorPiel');
    pielSelect.innerHTML = '';
    fenotipo.skinTones.forEach((tone, index) => {
      const option = document.createElement('option');
      option.value = tone.value;
      option.textContent = tone.name;
      option.selected = index === 0;
      pielSelect.appendChild(option);
    });

    // Llenar opciones de cabello
    const peloSelect = document.getElementById('colorCabello');
    peloSelect.innerHTML = '';
    fenotipo.hairColors.forEach((color, index) => {
      const option = document.createElement('option');
      option.value = color.value;
      option.textContent = color.name;
      option.selected = index === 0;
      peloSelect.appendChild(option);
    });

    // Llenar opciones de ojos
    const ojosSelect = document.getElementById('colorOjos');
    ojosSelect.innerHTML = '';
    fenotipo.eyeColors.forEach((color, index) => {
      const option = document.createElement('option');
      option.value = color.value;
      option.textContent = color.name;
      option.selected = index === 0;
      ojosSelect.appendChild(option);
    });

    // Actualizar previews
    updateColorPreviews();
  }

  function updateColorPreviews() {
    pielPreview.style.backgroundColor = document.getElementById('colorPiel').value;
    peloPreview.style.backgroundColor = document.getElementById('colorCabello').value;
    ojosPreview.style.backgroundColor = document.getElementById('colorOjos').value;
    ropaPreview.style.backgroundColor = document.getElementById('colorRopa').value;
  }

  // === SISTEMA DE CARAS CON EXPRESIONES DETALLADAS ===
  function createFaceTexture(config) {
    const canvas = document.createElement('canvas');
    canvas.width = CONFIG.faceResolution;
    canvas.height = CONFIG.faceResolution;
    const ctx = canvas.getContext('2d');
    
    // Fondo con color de piel
    ctx.fillStyle = config.skinColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // ConfiguraciÃ³n segÃºn expresiÃ³n
    const expressionConfig = getExpressionConfig(config.expression, config.intensity);
    const eyeColor = config.eyeColor || '#111111';
    
    // Dibujar caracterÃ­sticas faciales
    drawFacialFeatures(ctx, centerX, centerY, expressionConfig, eyeColor, config);
    
    // Crear textura
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
  }

  function getExpressionConfig(expression, intensity = 0.7) {
    const intensityFactor = intensity / 100;
    
    const configs = {
      neutro: {
        eyes: { type: 'normal', size: 35, yOffset: 0, rotation: 0, spacing: 100 },
        eyebrows: { type: 'neutral', yOffset: -60, angle: 0, curve: 0.1 },
        mouth: { type: 'neutral', width: 90, height: 10, yOffset: 40, curve: 0, open: 0 },
        cheeks: { blush: 0, puff: 0 },
        wrinkles: { eyes: 0, forehead: 0 }
      },
      feliz: {
        eyes: { type: 'happy', size: 32, yOffset: -5, rotation: -0.1, spacing: 110 },
        eyebrows: { type: 'raised', yOffset: -70, angle: 0.2, curve: 0.3 },
        mouth: { type: 'smile', width: 120, height: 15, yOffset: 35, curve: 0.4 * intensityFactor, open: 0.1 },
        cheeks: { blush: 0.6 * intensityFactor, puff: 0.4 * intensityFactor },
        wrinkles: { eyes: 0.3 * intensityFactor, forehead: 0.1 }
      },
      muy_feliz: {
        eyes: { type: 'closed_happy', size: 28, yOffset: -8, rotation: -0.2, spacing: 115 },
        eyebrows: { type: 'raised_high', yOffset: -80, angle: 0.3, curve: 0.4 },
        mouth: { type: 'big_smile', width: 140, height: 25, yOffset: 30, curve: 0.6 * intensityFactor, open: 0.3 * intensityFactor },
        cheeks: { blush: 0.8 * intensityFactor, puff: 0.7 * intensityFactor },
        wrinkles: { eyes: 0.6 * intensityFactor, forehead: 0.2 }
      },
      triste: {
        eyes: { type: 'sad', size: 38, yOffset: 10, rotation: 0.1, spacing: 95 },
        eyebrows: { type: 'sad', yOffset: -50, angle: -0.3, curve: 0.4 },
        mouth: { type: 'sad', width: 85, height: 12, yOffset: 45, curve: -0.3 * intensityFactor, open: 0.05 },
        cheeks: { blush: 0.3 * intensityFactor, puff: -0.2 * intensityFactor },
        wrinkles: { eyes: 0.2, forehead: 0.3 * intensityFactor }
      },
      furioso: {
        eyes: { type: 'angry_narrow', size: 30, yOffset: 5, rotation: 0, spacing: 90 },
        eyebrows: { type: 'angry', yOffset: -55, angle: -0.4, curve: 0.6 },
        mouth: { type: 'angry', width: 110, height: 8, yOffset: 38, curve: -0.1, open: 0.2 * intensityFactor },
        cheeks: { blush: 0.7 * intensityFactor, puff: 0.3 * intensityFactor },
        wrinkles: { eyes: 0.4 * intensityFactor, forehead: 0.8 * intensityFactor }
      },
      malvado: {
        eyes: { type: 'evil', size: 34, yOffset: 8, rotation: 0.15, spacing: 92 },
        eyebrows: { type: 'devilish', yOffset: -58, angle: 0.25, curve: 0.5 },
        mouth: { type: 'sinister', width: 115, height: 10, yOffset: 37, curve: 0.3 * intensityFactor, open: 0 },
        cheeks: { blush: 0.4 * intensityFactor, puff: 0.1 },
        wrinkles: { eyes: 0.3 * intensityFactor, forehead: 0.2 }
      },
      amor: {
        eyes: { type: 'loving', size: 33, yOffset: -3, rotation: -0.12, spacing: 105 },
        eyebrows: { type: 'soft', yOffset: -68, angle: 0.15, curve: 0.25 },
        mouth: { type: 'loving_smile', width: 125, height: 18, yOffset: 32, curve: 0.45 * intensityFactor, open: 0.15 },
        cheeks: { blush: 0.9 * intensityFactor, puff: 0.6 * intensityFactor },
        wrinkles: { eyes: 0.2 * intensityFactor, forehead: 0 }
      }
    };
    
    return configs[expression] || configs.neutro;
  }

  function drawFacialFeatures(ctx, centerX, centerY, config, eyeColor, charConfig) {
    // Ojos
    drawEyes(ctx, centerX, centerY + config.eyes.yOffset, config.eyes, eyeColor);
    
    // Cejas
    drawEyebrows(ctx, centerX, centerY + config.eyebrows.yOffset, config.eyebrows);
    
    // Boca
    drawMouth(ctx, centerX, centerY + config.mouth.yOffset, config.mouth);
    
    // Mejillas sonrojadas
    if (config.cheeks.blush > 0) {
      drawCheekBlush(ctx, centerX, centerY, config.cheeks.blush, charConfig.skinColor);
    }
    
    // Arrugas
    if (config.wrinkles.eyes > 0) {
      drawCrowsFeet(ctx, centerX, centerY, config.wrinkles.eyes);
    }
  }

  function drawEyes(ctx, centerX, centerY, config, eyeColor) {
    const eyeSpacing = config.spacing;
    const eyeSize = config.size;
    
    ctx.save();
    
    switch(config.type) {
      case 'normal':
        // Ojos normales redondos
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(centerX - eyeSpacing/2, centerY, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX + eyeSpacing/2, centerY, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Brillo
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(centerX - eyeSpacing/2 - eyeSize*0.3, centerY - eyeSize*0.3, eyeSize*0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX + eyeSpacing/2 - eyeSize*0.3, centerY - eyeSize*0.3, eyeSize*0.2, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'happy':
        // Ojos felices (entrecerrados)
        ctx.strokeStyle = eyeColor;
        ctx.lineWidth = eyeSize * 0.3;
        ctx.beginPath();
        ctx.arc(centerX - eyeSpacing/2, centerY, eyeSize * 0.6, 0, Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(centerX + eyeSpacing/2, centerY, eyeSize * 0.6, 0, Math.PI);
        ctx.stroke();
        break;
        
      case 'closed_happy':
        // Ojos cerrados de risa
        ctx.strokeStyle = eyeColor;
        ctx.lineWidth = eyeSize * 0.4;
        ctx.beginPath();
        ctx.arc(centerX - eyeSpacing/2, centerY, eyeSize * 0.7, 0, Math.PI * 0.8);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(centerX + eyeSpacing/2, centerY, eyeSize * 0.7, 0, Math.PI * 0.8);
        ctx.stroke();
        break;
        
      case 'sad':
        // Ojos tristes
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.ellipse(centerX - eyeSpacing/2, centerY, eyeSize, eyeSize * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(centerX + eyeSpacing/2, centerY, eyeSize, eyeSize * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'angry_narrow':
        // Ojos enojados estrechos
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.ellipse(centerX - eyeSpacing/2, centerY, eyeSize * 0.9, eyeSize * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(centerX + eyeSpacing/2, centerY, eyeSize * 0.9, eyeSize * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
    }
    
    ctx.restore();
  }

  function drawEyebrows(ctx, centerX, centerY, config) {
    const browLength = 50;
    const browHeight = 8;
    
    ctx.save();
    ctx.strokeStyle = '#111111';
    ctx.lineWidth = browHeight;
    ctx.lineCap = 'round';
    
    // Ceja izquierda
    ctx.save();
    ctx.translate(centerX - 70, centerY);
    ctx.rotate(config.angle);
    ctx.beginPath();
    ctx.moveTo(-browLength/2, 0);
    ctx.quadraticCurveTo(0, -config.curve * 30, browLength/2, 0);
    ctx.stroke();
    ctx.restore();
    
    // Ceja derecha
    ctx.save();
    ctx.translate(centerX + 70, centerY);
    ctx.rotate(-config.angle);
    ctx.beginPath();
    ctx.moveTo(-browLength/2, 0);
    ctx.quadraticCurveTo(0, -config.curve * 30, browLength/2, 0);
    ctx.stroke();
    ctx.restore();
    
    ctx.restore();
  }

  function drawMouth(ctx, centerX, centerY, config) {
    ctx.save();
    
    if (config.open > 0) {
      // Boca abierta
      ctx.fillStyle = '#111111';
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, config.width/2, config.height * (1 + config.open), 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Dientes
      ctx.fillStyle = '#ffffff';
      const toothWidth = config.width / 8;
      for (let i = -3; i <= 3; i++) {
        if (i !== 0) {
          ctx.fillRect(centerX + i * toothWidth - toothWidth/2, centerY - config.height, toothWidth, config.height);
        }
      }
    } else {
      // Boca cerrada
      ctx.strokeStyle = '#111111';
      ctx.lineWidth = config.height;
      ctx.lineCap = 'round';
      
      ctx.beginPath();
      ctx.moveTo(centerX - config.width/2, centerY);
      if (config.curve !== 0) {
        ctx.quadraticCurveTo(centerX, centerY + config.curve * 30, centerX + config.width/2, centerY);
      } else {
        ctx.lineTo(centerX + config.width/2, centerY);
      }
      ctx.stroke();
    }
    
    ctx.restore();
  }

  function drawCheekBlush(ctx, centerX, centerY, intensity, skinColor) {
    const blushColor = `rgba(255, 100, 100, ${intensity * 0.6})`;
    const blushSize = 40;
    
    ctx.save();
    ctx.fillStyle = blushColor;
    
    // Mejilla izquierda
    ctx.beginPath();
    ctx.arc(centerX - 80, centerY + 20, blushSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Mejilla derecha
    ctx.beginPath();
    ctx.arc(centerX + 80, centerY + 20, blushSize, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }

  function drawCrowsFeet(ctx, centerX, centerY, intensity) {
    ctx.save();
    ctx.strokeStyle = `rgba(0, 0, 0, ${intensity * 0.4})`;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    // Patas de gallo izquierdas
    for (let i = 0; i < 3; i++) {
      const angle = Math.PI / 6 + i * Math.PI / 12;
      const length = 15 + i * 5;
      ctx.beginPath();
      ctx.moveTo(centerX - 80 + Math.cos(angle) * 30, centerY - 10 + Math.sin(angle) * 30);
      ctx.lineTo(centerX - 80 + Math.cos(angle) * (30 + length), centerY - 10 + Math.sin(angle) * (30 + length));
      ctx.stroke();
    }
    
    // Patas de gallo derechas
    for (let i = 0; i < 3; i++) {
      const angle = Math.PI * 5/6 - i * Math.PI / 12;
      const length = 15 + i * 5;
      ctx.beginPath();
      ctx.moveTo(centerX + 80 + Math.cos(angle) * 30, centerY - 10 + Math.sin(angle) * 30);
      ctx.lineTo(centerX + 80 + Math.cos(angle) * (30 + length), centerY - 10 + Math.sin(angle) * (30 + length));
      ctx.stroke();
    }
    
    ctx.restore();
  }

  // === FABRICA DE PERSONAJES ===
  const geoHead = new THREE.SphereGeometry(1.1, 32, 32);
  const geoTorsoMale = new THREE.CylinderGeometry(0.9, 1.2, 1.8, 8, 1);
  const geoTorsoFemale = new THREE.CylinderGeometry(0.7, 1.1, 1.6, 8, 1);
  const geoTorsoChild = new THREE.CylinderGeometry(0.6, 0.9, 1.4, 8, 1);
  const geoLimb = new THREE.CylinderGeometry(0.35, 0.35, 1.2, 16);
  const geoHand = new THREE.SphereGeometry(0.2, 16, 16);

  function getMaterial(color, isSkin = false) {
    return new THREE.MeshStandardMaterial({
      color: color,
      roughness: isSkin ? 0.4 : CONFIG.plasticRoughness,
      metalness: isSkin ? 0.05 : CONFIG.plasticMetalness,
      envMapIntensity: 1.0
    });
  }

  function createCharacter(pos, customConfig = null) {
    // Obtener configuraciÃ³n del formulario
    const config = customConfig || {
      genero: document.getElementById('genero').value,
      edad: document.getElementById('edad').value,
      fenotipo: document.getElementById('fenotipo').value,
      piel: document.getElementById('colorPiel').value,
      ropa: document.getElementById('colorRopa').value,
      pelo: document.getElementById('colorCabello').value,
      ojos: document.getElementById('colorOjos').value,
      tipoCabello: document.getElementById('tipoCabello').value,
      expresion: document.getElementById('expresion').value,
      intensidad: parseInt(intensidadSlider.value)
    };

    const group = new THREE.Group();
    group.userData.type = 'character';
    group.userData.config = config;
    group.userData.expresion = config.expresion;

    const matSkin = getMaterial(config.piel, true);
    const matClothes = getMaterial(config.ropa);
    const matHair = getMaterial(config.pelo);

    // Determinar caracterÃ­sticas segÃºn edad y gÃ©nero
    const isFemale = config.genero === 'mujer';
    const isChild = config.edad === 'nino';
    const isYoung = config.edad === 'joven';
    const isElder = config.edad === 'anciano';
    
    // Seleccionar torso segÃºn gÃ©nero y edad
    let torsoGeo;
    if (isChild) {
      torsoGeo = geoTorsoChild;
    } else if (isFemale) {
      torsoGeo = geoTorsoFemale;
    } else {
      torsoGeo = geoTorsoMale;
    }

    // ConstrucciÃ³n del cuerpo
    // Piernas
    const legL = new THREE.Mesh(geoLimb, matClothes); 
    legL.position.set(-0.6, 0.6, 0); 
    legL.castShadow = true;
    
    const legR = new THREE.Mesh(geoLimb, matClothes); 
    legR.position.set(0.6, 0.6, 0); 
    legR.castShadow = true;

    // Cadera
    const hip = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.4, 0.8), matClothes); 
    hip.position.y = 1.3; 
    hip.castShadow = true;

    // Torso
    const torso = new THREE.Mesh(torsoGeo, matClothes);
    torso.position.y = 2.3;
    torso.rotation.y = Math.PI/4;
    torso.castShadow = true;

    // CABEZA CON EXPRESIÃ“N
    const faceTexture = createFaceTexture({
      skinColor: config.piel,
      eyeColor: config.ojos,
      expression: config.expresion,
      intensity: config.intensidad / 100
    });
    
    const matFace = new THREE.MeshStandardMaterial({
      map: faceTexture,
      roughness: 0.4,
      metalness: 0.1
    });
    
    const head = new THREE.Mesh(geoHead, matFace);
    head.position.y = 3.7;
    head.castShadow = true;
    head.rotation.y = -Math.PI / 2;

    // Brazos
    const armLength = isChild ? 0.9 : 1.2;
    const armGeo = new THREE.CylinderGeometry(0.3, 0.3, armLength, 12);
    
    const armL = new THREE.Mesh(armGeo, matClothes); 
    armL.position.set(-1.3, 2.8, 0); 
    armL.rotation.z = 0.2; 
    armL.castShadow = true;
    
    const handL = new THREE.Mesh(geoHand, matSkin);
    handL.position.set(0, -0.7, 0);
    armL.add(handL);
    
    const armR = new THREE.Mesh(armGeo, matClothes); 
    armR.position.set(1.3, 2.8, 0); 
    armR.rotation.z = -0.2; 
    armR.castShadow = true;
    
    const handR = new THREE.Mesh(geoHand, matSkin);
    handR.position.set(0, -0.7, 0);
    armR.add(handR);

    // CABELLO SEGÃšN TIPO
    const hairType = config.tipoCabello;
    const hairConfig = HAIR_TYPES[hairType] || HAIR_TYPES.lacio;
    
    let hair;
    if (hairType === 'calvo') {
      // Para calvo, solo agregar si no es completamente calvo
      const hairGeometry = hairConfig.geometry(isFemale, isChild);
      if (hairGeometry.children.length > 0) {
        hair = hairGeometry;
        hair.traverse(child => {
          if (child.isMesh) {
            child.material = matHair;
            child.castShadow = true;
          }
        });
        hair.scale.set(hairConfig.scale.x, hairConfig.scale.y, hairConfig.scale.z);
        hair.position.set(0, hairConfig.position.y, hairConfig.position.z);
        head.add(hair);
      }
    } else {
      const hairGeometry = hairConfig.geometry(isFemale, isChild);
      
      if (hairGeometry.isGroup) {
        // Es un grupo de geometrÃ­as
        hair = hairGeometry;
        hair.traverse(child => {
          if (child.isMesh) {
            child.material = matHair;
            child.castShadow = true;
          }
        });
      } else {
        // Es una sola geometrÃ­a
        hair = new THREE.Mesh(hairGeometry, matHair);
        hair.castShadow = true;
      }
      
      hair.scale.set(hairConfig.scale.x, hairConfig.scale.y, hairConfig.scale.z);
      hair.position.set(0, hairConfig.position.y, hairConfig.position.z);
      hair.rotation.set(hairConfig.rotation.x, hairConfig.rotation.y, hairConfig.rotation.z);
      head.add(hair);
    }

    // Agrupar todo
    group.add(legL, legR, hip, torso, head, armL, armR);

    // Ajustes por edad
    if (isChild) {
      group.scale.set(0.65, 0.65, 0.65);
    } else if (isElder) {
      group.scale.set(0.95, 0.9, 0.95);
      group.rotation.x = 0.12; // Leve encorvamiento
    } else if (isYoung) {
      group.scale.set(0.9, 0.95, 0.9); // Estatura juvenil
    }

    // Posicionar
    group.position.set(pos.x, 0, pos.z);
    
    // AnimaciÃ³n de entrada
    group.position.y = 15;
    let startTime = performance.now();
    function animateSpawn(time) {
      let elapsed = (time - startTime) / 1000;
      if (elapsed > 1) elapsed = 1;
      let ease = 1 - Math.pow(1 - elapsed, 4); // Ease out quart
      group.position.y = 15 - (15 * ease);
      if (elapsed < 1) {
        requestAnimationFrame(animateSpawn);
      }
    }
    requestAnimationFrame(animateSpawn);

    scene.add(group);
    characters.push(group);
    selectCharacter(group);
    
    return group;
  }

  function updateCharacterExpression(character, expression, intensity = null) {
    if (!character || !character.userData.config) return;
    
    const config = character.userData.config;
    config.expresion = expression;
    if (intensity !== null) {
      config.intensidad = intensity;
    }
    character.userData.expresion = expression;
    
    // Encontrar la cabeza del personaje
    let head = null;
    character.traverse(child => {
      if (child.geometry && child.geometry.type === 'SphereGeometry' && child.parent === character) {
        head = child;
      }
    });
    
    if (head && head.material.map) {
      // Crear nueva textura con la expresiÃ³n actualizada
      const newTexture = createFaceTexture({
        skinColor: config.piel,
        eyeColor: config.ojos,
        expression: expression,
        intensity: (intensity || config.intensidad) / 100
      });
      
      // Actualizar material
      head.material.map.dispose();
      head.material.map = newTexture;
      head.material.needsUpdate = true;
    }
  }

  // === INTERACCIÃ“N ===
  function setupInteraction() {
    // Mouse events
    container.addEventListener('mousedown', onMouseDown);
    container.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);

    // UI events
    document.getElementById('btnCrear').addEventListener('click', () => {
      if (characters.length >= CONFIG.maxCharacters) {
        alert(`MÃ¡ximo ${CONFIG.maxCharacters} personajes permitidos.`);
        return;
      }
      
      const angle = Math.random() * Math.PI * 2;
      const r = 5 + Math.random() * 12;
      createCharacter({ 
        x: Math.cos(angle) * r, 
        z: Math.sin(angle) * r 
      });
    });

    document.getElementById('btnBorrarSel').addEventListener('click', () => {
      if (selectedCharacter) {
        scene.remove(selectedCharacter);
        characters = characters.filter(c => c !== selectedCharacter);
        deselect();
      }
    });
    
    document.getElementById('btnReset').addEventListener('click', () => {
      if (confirm("Â¿Borrar todos los personajes de la escena?")) {
        characters.forEach(c => scene.remove(c));
        characters = [];
        deselect();
      }
    });

    document.getElementById('btnFoto').addEventListener('click', () => {
      deselect();
      renderer.render(scene, camera);
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.download = `lego-expression-${timestamp}.png`;
      link.href = renderer.domElement.toDataURL('image/png', 1.0);
      link.click();
    });

    document.getElementById('btnExpresionAleatoria').addEventListener('click', () => {
      const randomExpr = EXPRESSIONS[Math.floor(Math.random() * EXPRESSIONS.length)];
      document.getElementById('expresion').value = randomExpr.id;
      
      // Actualizar UI
      document.querySelectorAll('.expression-tile').forEach((tile, index) => {
        tile.classList.remove('active');
        if (EXPRESSIONS[index].id === randomExpr.id) {
          tile.classList.add('active');
        }
      });
      
      // Aplicar a personaje seleccionado
      if (selectedCharacter) {
        updateCharacterExpression(selectedCharacter, randomExpr.id);
      }
    });

    document.getElementById('btnCopiar').addEventListener('click', () => {
      if (selectedCharacter) {
        const config = { ...selectedCharacter.userData.config };
        const angle = Math.random() * Math.PI * 2;
        const r = 3 + Math.random() * 8;
        createCharacter({ 
          x: selectedCharacter.position.x + Math.cos(angle) * r,
          z: selectedCharacter.position.z + Math.sin(angle) * r
        }, config);
      }
    });

    // ExpresiÃ³n rÃ¡pida con teclas 1-9
    window.addEventListener('keydown', (e) => {
      if (e.key >= '1' && e.key <= '9') {
        const index = parseInt(e.key) - 1;
        if (index < EXPRESSIONS.length) {
          const expr = EXPRESSIONS[index];
          document.getElementById('expresion').value = expr.id;
          
          // Actualizar UI
          document.querySelectorAll('.expression-tile').forEach((tile, i) => {
            tile.classList.toggle('active', i === index);
          });
          
          // Aplicar a personaje seleccionado
          if (selectedCharacter) {
            updateCharacterExpression(selectedCharacter, expr.id);
          }
        }
      }
    });
  }

  function onMouseDown(e) {
    if (e.target !== renderer.domElement) return;
    const rect = container.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    const intersects = raycaster.intersectObjects(characters, true);
    if (intersects.length > 0) {
      let target = intersects[0].object;
      while (target.parent && target.userData.type !== 'character') {
        target = target.parent;
      }
      if (target.userData.type === 'character') {
        controls.enabled = false;
        isDragging = true;
        draggedCharacter = target;
        selectCharacter(target);
        draggedCharacter.position.y = 0.5; // Levantar ligeramente
      }
    } else {
      deselect();
    }
  }

  function calculateDragBounds() {
    const ndcCorners = [
      new THREE.Vector2(-1, -1),
      new THREE.Vector2(1, -1),
      new THREE.Vector2(-1, 1),
      new THREE.Vector2(1, 1)
    ];

    const intersectPoint = new THREE.Vector3();
    const bounds = {
      minX: Infinity,
      maxX: -Infinity,
      minZ: Infinity,
      maxZ: -Infinity
    };

    for (const corner of ndcCorners) {
      dragBoundsRaycaster.setFromCamera(corner, camera);
      if (dragBoundsRaycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
        bounds.minX = Math.min(bounds.minX, intersectPoint.x);
        bounds.maxX = Math.max(bounds.maxX, intersectPoint.x);
        bounds.minZ = Math.min(bounds.minZ, intersectPoint.z);
        bounds.maxZ = Math.max(bounds.maxZ, intersectPoint.z);
      }
    }

    if (!Number.isFinite(bounds.minX)) {
      return null;
    }

    return bounds;
  }

  function onMouseMove(e) {
    if (!isDragging || !draggedCharacter) return;
    const rect = container.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersect = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersect);
    if (intersect) {
      const bounds = calculateDragBounds();
      if (!bounds) return;

      const clampedX = THREE.MathUtils.clamp(intersect.x, bounds.minX, bounds.maxX);
      const clampedZ = THREE.MathUtils.clamp(intersect.z, bounds.minZ, bounds.maxZ);
      draggedCharacter.position.x = clampedX;
      draggedCharacter.position.z = clampedZ;
      selectionRing.position.set(clampedX, 0.05, clampedZ);
    }
  }

  function onMouseUp() {
    if (draggedCharacter) draggedCharacter.position.y = 0;
    isDragging = false;
    draggedCharacter = null;
    controls.enabled = true;
  }

  function selectCharacter(character) {
    selectedCharacter = character;
    selectionRing.visible = true;
    selectionRing.position.set(character.position.x, 0.05, character.position.z);
    uiSelection.classList.add('active');
    rotSlider.value = character.rotation.y;
    rotationValue.textContent = `${Math.round(character.rotation.y * 180 / Math.PI)}Â°`;
  }

  function deselect() {
    selectedCharacter = null;
    selectionRing.visible = false;
    uiSelection.classList.remove('active');
  }

  // === ANIMACIÃ“N ===
  function animate() {
    requestAnimationFrame(animate);
    if (selectionRing.visible) {
      selectionRing.rotation.z -= 0.02; // RotaciÃ³n continua del anillo
    }
    controls.update();
    renderer.render(scene, camera);
  }

  // === RESIZE HANDLER ===
  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });

  // === INICIAR APLICACIÃ“N ===
  document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>